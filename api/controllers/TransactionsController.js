/**
 * TransactionsController
 *
 * @description :: Server-side actions for handling incoming requests.
 * @help        :: See https://sailsjs.com/docs/concepts/actions
 */
const ICHIPS = new IChipsService();
const ENV = sails.config;

module.exports = {
  /**
   * Calculate payouts
   * @route POST /transaction/payout
   * @param req
   * @param res
   */
  calculatePayout: function (req, res) {
    const {cacheKey, gameSet, tableNumber, gameType} = req.body;
    let tasks, tableId, shoeId, resultId, resultListId;

    console.log(`| # PAYOUT API - ${gameSet} | : ${JSON.stringify({cacheKey, gameSet, tableNumber, gameType})}`);

    // Validators
    if (_.isUndefined(tableNumber))     return res.json({ err: "Invalid Parameter: [tableNumber]" });
    if (_.isUndefined(cacheKey))        return res.json({ err: "Invalid Parameter: [cacheKey]" });
    else if (_.isUndefined(gameSet))    return res.json({ err: "Invalid Parameter: [gameSet]" });
    else if (_.isUndefined(gameType))   return res.json({ err: "Invalid Parameter: [gameType]" });

    tasks = {
      /*
         ___              _                _     __                    _  _
        / __\ __ _   ___ | |__    ___   __| |   /__\  ___  ___  _   _ | || |_
       / /   / _` | / __|| '_ \  / _ \ / _` |  / \// / _ \/ __|| | | || || __|
      / /___| (_| || (__ | | | ||  __/| (_| | / _  \|  __/\__ \| |_| || || |_
      \____/ \__,_| \___||_| |_| \___| \__,_| \/ \_/ \___||___/ \__,_||_| \__|
        Get cached result generated by game-app server
       */
      cachedResult: (cb) => {
        console.log(`| #1 PAYOUT API - ${gameSet} | : CACHED RESULTS.`);
        let parsedData;
        CacheService.get(cacheKey, async (err, cache) => {
          if (err) {
            console.error(`| #1.1 PAYOUT API - ${gameSet} | : Cached result failed to pull. ${JSON.stringify(err)}`);
            return cb(err);
          }

          if(!cache) {
            console.error(`| #1.1 PAYOUT API - ${gameSet} | : Cached result saved by Game-App Server is invalid. ${cache}`);
            return cb("Cached result saved by Game-App Server is invalid.");
          }

          parsedData = JSONParseSafe(cache) || {};

          // Assign value to pre-defined variable
          tableId = _.get(parsedData, 'idTableNo', null);
          shoeId = _.get(parsedData, 'idShoeHand', null);
          resultId = _.get(parsedData, 'id', null);
          resultListId = _.get(parsedData, 'idResultList', null);

          // Pre-validation
          if(!tableId)
            return cb("Invalid cached data: [idTableNo] => " + typeof tableId);
          if (!shoeId)
            return cb("Invalid cached data: [idShoeHand] => " + typeof shoeId);
          if (!resultListId)
            return cb("Invalid cached data: [idResultList] => " + typeof resultListId);
          if (!resultId)
            return cb("Invalid cached data: [id] => " + typeof resultId);

          console.log(`| #1.1 PAYOUT API - ${gameSet} | : Cached result pulled successful. ${JSON.stringify({tableId, shoeId, resultId, resultListId})}`);
          return cb(null, {tableId, shoeId, resultId, resultListId});
        });
      },

      /*
         ___        _                            _     __                    _  _
        / __\  ___ | |_  ___    __ _  _ __    __| |   /__\  ___  ___  _   _ | || |_  ___
       /__\// / _ \| __|/ __|  / _` || '_ \  / _` |  / \// / _ \/ __|| | | || || __|/ __|
      / \/  \|  __/| |_ \__ \ | (_| || | | || (_| | / _  \|  __/\__ \| |_| || || |_ \__ \
      \_____/ \___| \__||___/  \__,_||_| |_| \__,_| \/ \_/ \___||___/ \__,_||_| \__||___/
        Get all bets and result executed on this round
       */
      getBetsAndResult: ['cachedResult', (arg, cb) => {
        console.log(`| #2 PAYOUT API - ${gameSet} | : PLAYER BETS`);
        const _q = "CALL PAYOUT_PLAYER_BETS($1, $2, $3);";
        const _d = [ tableId, shoeId, gameSet ];
        let returnData = { bets: [], result: {}, other: {} };

        // Run it parallel for optimization
        async.series([
          // Retrieve bets
          (cb) => {
            console.log(`| #2.1 PAYOUT API - ${gameSet} | : Getting all player bets from database.`);
            sails
              .sendNativeQuery(_q, _d)
              .exec((err, bets) => {
                if (err)
                  return cb(err);
                // Check if there are bets to calculate
                if(_.isEmpty(_.get(bets, 'rows[0]', [])))
                  return cb("NO_BETS");

                console.log(`| #2.1 PAYOUT API - ${gameSet} | : Player bets pulled.[ ${_.size(bets.rows[0])} bet(s) ]`);
                returnData.bets = _.get(bets, 'rows[0]', []);
                return cb();
              });
          },
          // Retrieve results
          (cb) => {
            console.log(`| #2.2 PAYOUT API - ${gameSet} | : Getting game result.`);
            ResultList.findOne({
              id: resultListId // banker,banker_pair,super_six
            }, (err, resultList) => {
              if(err)
                return cb(err);
              // Check if there game result to calculate
              if(_.isEmpty(resultList))
                return cb("No result to be calculated.");

              console.log(`| #2.2 PAYOUT API - ${gameSet} | : Game result pulled.[ ${JSON.stringify(resultList)} ]`);
              returnData.result = resultList;
              return cb();
            });
          },
          // Others exclusive to `gameResult` for `calculate` tasks below
          (cb) => {
            let data;
            console.log(`| #2.3 PAYOUT API - ${gameSet} | : Others exclusive to gameResult for calculate.`);

            if (!_.includes(["moneywheel", "niuniu"], gameType))
              return cb();

            GameValues.findOne({
              result_id: resultId
            }, (err, gameValue) => {
              // Validators
              if (err)
                return cb(err);

              if (_.isEmpty(gameValue))
                return cb("Game values for " + gameType + " is missing.");

              switch (gameType) {
                case "moneywheel":
                  data = JSONParseSafe(gameValue.values) || {};
                  _.assign(returnData.other, {
                    moneywheel: {
                      multiplier: Math.pow(3, _.split(data.values,',').length - 1)
                    }
                  });
                  break;

                case "niuniu":
                  data = JSONParseSafe(gameValue.values) || {};
                  _.assign(returnData.other, {
                    niuniu: {
                      rawResult: {
                        player1: _.get(data, "player1Result", ""),
                        player2: _.get(data, "player2Result", ""),
                        player3: _.get(data, "player3Result", ""),
                        banker: _.get(data, "bankerResult", "")
                      }
                    }
                  });
                  break;
              }

              console.log(`| #2.3 PAYOUT API - ${gameSet} | : Other info pulled.[ ${JSON.stringify(returnData.other)} ]`);
              return cb();
            });

          }
        ], async (err) => {
          return cb(err, returnData);
        });
      }],

      /*
         ___        _               _         _    _
        / __\ __ _ | |  ___  _   _ | |  __ _ | |_ (_)  ___   _ __
       / /   / _` || | / __|| | | || | / _` || __|| | / _ \ | '_ \
      / /___| (_| || || (__ | |_| || || (_| || |_ | || (_) || | | |
      \____/ \__,_||_| \___| \__,_||_| \__,_| \__||_| \___/ |_| |_|
        Start calculation of payouts for Baccarat, Dragon-Tiger, Money wheel and Roulette
       */
      calculate: ["getBetsAndResult", async (arg, cb) => {
        console.log(`| #3 PAYOUT API - ${gameSet} | : BET CALCULATIONS`);
        const gameMapper = {
          baccarat    : "Baccarat",
          dragontiger : "DragonTiger",
          moneywheel  : "MoneyWheel",
          roulette    : "Roulette",
          threecards  : "3Cards",
          niuniu      : "Niuniu"
        };
        let payLoad = {
          bets: arg.getBetsAndResult.bets,
          gameResult: {
            multiplier: _.get(arg.getBetsAndResult, 'other.moneywheel.multiplier', 1),
          },
          gameResultList: arg.getBetsAndResult.result
        };
        let payout;

        // If there's a custom gameResult additives calculations
        if (!_.isEmpty(arg.getBetsAndResult.other)) {
          _.assign(payLoad.gameResult, arg.getBetsAndResult.other[gameType]);
        }

        payout = await sails.helpers.payoutHelper('calculatePayout' + gameMapper[gameType], payLoad);

        console.log(`| #3 PAYOUT API - ${gameSet} | : Bet calculation done.`);
        return cb(null, payout);
      }],

      /*
       __    __  _                  __
      / / /\ \ \(_) _ __           / /   ___   ___  ___
      \ \/  \/ /| || '_ \  _____  / /   / _ \ / __|/ __|
       \  /\  / | || | | ||_____|/ /___| (_) |\__ \\__ \
        \/  \/  |_||_| |_|       \____/ \___/ |___/|___/
        Update bets win-loss of players
       */
      updateWinLoss: ["calculate", "getBetsAndResult", async (results, cb) => {
        console.log(`| #4 PAYOUT API - ${gameSet} | : UPDATE WIN-LOSS`);
        let payouts = results.calculate.payout;
        let totalWinning = {};
        let totalLoss = {};
        let totalWin = {};
        let iChipsPayoutData = [];
        const gameMapper = {
          baccarat    : "baccarat",
          dragontiger : "dragontiger",
          moneywheel  : "moneywheel",
          roulette    : "roulette",
          threecards  : "3cards",
          niuniu      : "niuniu"
        };

        console.time("WINLOSS_TIME");

        // If no payout skip computation
        if (!payouts.length)
          return cb(null, { totalWinning, iChipsPayoutData });

        /**
         * DEVELOPERS NOTE
         * Even one bet error occurs, the other bet will continue to proceed while the erroneous bet will be logged
         */
        async.forEachOf(payouts, async (payout, i, cb) => {
          const winLoss = parseFloat(payout.win_loss);
          const betAmount = parseFloat(payout.bet_amount);
          const betCode = payout.bet_code;
          const username = payout.username;
          const userId = parseInt(payout.user_id);
          let effectiveBetAmount, winLossAmt, lossAmt, winAmt;

          // Pre-calculation
          effectiveBetAmount = Math.abs(winLoss) > betAmount ? betAmount : Math.abs(winLoss);
          winLossAmt = (winLoss >= 0) ? parseFloat(betAmount + winLoss) : 0;
          lossAmt = (winLoss <= 0) ? parseFloat(winLoss) : 0;
          winAmt = (winLoss >= 0) ? parseFloat(winLoss) : 0;

          if (winLoss === (betAmount * -.5))
            winLossAmt = betAmount * .5;

          if (!_.has(totalWinning, userId)) {
            _.assign(totalWinning, {[userId]: 0});
          }

          if (!_.has(totalLoss, userId)) {
            _.assign(totalLoss, {[userId]: 0});
          }

          if (!_.has(totalWin, userId)) {
            _.assign(totalWin, {[userId]: 0});
          }

          totalWinning[userId] += winLossAmt;
          totalLoss[userId] += lossAmt;
          totalWin[userId] += winAmt;

          iChipsPayoutData.push({
            user_id: userId,
            username: username,
            amount: winLossAmt,
            betting_code: betCode,
            game_code: gameMapper[gameType]
          });

          // Execute betting update query
          await Bettings
            .update({
              bet_code: betCode,
              user_id: userId
            })
            .set({
              result_id: resultId,
              resultlist_id: resultListId,
              win_loss: winLoss,
              effective_bet_amount: effectiveBetAmount
            })
            .intercept((err) => {
              console.log(`| #4.1 PAYOUT API - ${gameSet} | : ENCOUNTER ERROR WHILE UPDATING => ${bet_code}`);
              console.log(`| #4.1 PAYOUT API - ${gameSet} | : ${JSON.stringify(err)}`);
            });

          return cb();
        }, () => {
          console.timeEnd("WINLOSS_TIME");
          console.log(`| #4 PAYOUT API - ${gameSet} | : UPDATE WIN-LOSS DONE`);
          return cb(null, { totalWinning, iChipsPayoutData, totalLoss, totalWin })
        });
      }],

      /*
       _    ___  _      _                _____         _                            _    _
      (_)  / __\| |__  (_) _ __   ___    \_   \ _ __  | |_  ___   __ _  _ __  __ _ | |_ (_)  ___   _ __
      | | / /   | '_ \ | || '_ \ / __|    / /\/| '_ \ | __|/ _ \ / _` || '__|/ _` || __|| | / _ \ | '_ \
      | |/ /___ | | | || || |_) |\__ \ /\/ /_  | | | || |_|  __/| (_| || |  | (_| || |_ | || (_) || | | |
      |_|\____/ |_| |_||_|| .__/ |___/ \____/  |_| |_| \__|\___| \__, ||_|   \__,_| \__||_| \___/ |_| |_|
                          |_|                                    |___/
        I-Chips integration processing
       */
      iChips: ["updateWinLoss", (arg, cb) => {
        console.log(`| #5 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION`);
        let iChips = { userBalance: {} };
        const gameMapper = {
          baccarat    : "baccarat",
          dragontiger : "dragontiger",
          moneywheel  : "moneywheel",
          roulette    : "roulette",
          threecards  : "3cards",
          niuniu      : "niuniu"
        };
        let tasks;
        // console.log("RAW DATA => ", arg.updateWinLoss.iChipsPayoutData);

        tasks = {
          // Saving game result
          gameResult: (cb) => {
            console.log(`| #5.1 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - GAME RESULT`);

            ichipsApi('insertGameResult', { result_id: resultId, game_type: gameMapper[gameType], gameSet })
              .then(() => {
                console.log(`| #5.1 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - Saving game results done.`);
                return cb();
              }, (error) => {
                console.log(`| #5.1 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - Saving game results encounters error.`);
                return cb(new Error(error));
              });
          },

          // Payout balance
          payoutBalance: ["gameResult", (_arg, cb) => {
            console.log(`| #5.2 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - PAYOUT`);

            ichipsApi('payoutBalance', { iChipsPayoutData: arg.updateWinLoss.iChipsPayoutData, gameSet })
              .then((result) => {
                console.log(`| #5.2 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - Payout done.[ ${JSON.stringify(result.user)} ]`);
                iChips.userBalance = result.user;
                return cb();
              }, (error) => {
                console.log(`| #5.2 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - Payout encounters error.[ ${JSON.stringify(error)} ]`);
                return cb(new Error(error));
              });
          }],

          // Transactions / Bets
          transaction: ["payoutBalance", (_arg, cb) => {
            console.log(`| #5.3 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - TRANSACTION`);

            async.forEachOf(arg.updateWinLoss.totalWinning, async (winLoss, userId, cb) => {
              ichipsApi('insertTransaction', {
                gameset_id: gameSet,
                game_type: gameMapper[gameType],
                balance: parseFloat(iChips.userBalance[userId]),
                user_id: userId
              })
                .then(() => {
                  console.log(`| #5.3 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - Transaction saved.`);
                  return cb()
                }, (error) => {
                  console.log(`| #5.3 PAYOUT API - ${gameSet} | : I-CHIPS INTEGRATION - Saving transaction encounters error.`);
                  return cb(new Error(error));
                });
            }, cb);
          }]
        };

        async.auto(tasks, (err) => {
          if (err)
            return cb(err);
          return cb(null, iChips);
        });
      }],

      /*
                         _         _            ___         _
       /\ /\  _ __    __| |  __ _ | |_  ___    / __\  __ _ | |  __ _  _ __    ___  ___
      / / \ \| '_ \  / _` | / _` || __|/ _ \  /__\// / _` || | / _` || '_ \  / __|/ _ \
      \ \_/ /| |_) || (_| || (_| || |_|  __/ / \/  \| (_| || || (_| || | | || (__|  __/
       \___/ | .__/  \__,_| \__,_| \__|\___| \_____/ \__,_||_| \__,_||_| |_| \___|\___|
             |_|
        Update of player's balance
       */
      updateUserBalance: ["iChips", "updateWinLoss", (arg, cb) => {
        console.log(`| #5 PAYOUT API - ${gameSet} | : UPDATE BALANCE`);
        const playerNewBalance = _.get(arg.iChips, 'userBalance', {});
        const { totalWinning, totalLoss, totalWin } = arg.updateWinLoss;
        let playerGroup = [];

        async.forEachOf(totalWinning, async (winLoss, userId, cb) => {
          let subTasks = {
            "step1": (cb) => {
              // Update bets logs balance
              Bettings.update({
                user_id: userId,
                shoehand_id: shoeId
              }, {
                balance: parseFloat(playerNewBalance[userId])
              }).exec(cb);
            },
            "step2": ["step1", (arg, cb) => {
              // Update current balance
              Users.update({
                id: userId
              },{
                balance: parseFloat(playerNewBalance[userId])
              }).exec(cb);
            }]
          };

          async.auto(subTasks, async (err) => {
            if (err) return cb(err);

            // Consolidate player balances
            playerGroup.push({
              balance: parseFloat(playerNewBalance[userId]),
              id: await syfer('encrypt', userId)
            });

            await balanceUpdate('player', {
              id: parseInt(userId),
              balance: parseFloat(playerNewBalance[userId]),
              winnings: totalWinning[userId],
              loss: totalLoss[userId],
              win: totalWin[userId],
              table: tableNumber
            });

            return cb();
          });
        }, async (err) => {
          if (err) return cb(err);

          // Update all players in the table
          await balanceUpdate('table', {
            tablenumber: tableNumber,
            playerGroup: playerGroup
          });

          return cb();
        });
      }]
    };

    console.time("PAYOUT_TIME");

    async.auto(tasks, (err) => {
      if (err) {
        if (err === "NO_BETS") {
          console.log(`| #6 PAYOUT API - ${gameSet} | : PAYOUT SKIPPED, NOTHING TO CALCULATE.`);
          return res.json({ msg: 'Payout Successful (No bets to calculate)' });
        } else {
          console.log(`| #6 PAYOUT API - ${gameSet} | : PAYOUT FAILED.`);
          console.log(`| #6 PAYOUT API - ${gameSet} | : ${JSON.stringify(err)}`);
          return res.badRequest({ error: JSON.stringify(err) });
        }
      }

      console.log(`| #6 PAYOUT API - ${gameSet} | : PAYOUT SUCCESSFUL.`);
      console.timeEnd("PAYOUT_TIME");
      return res.json({ msg: 'Payout Successful' });
    });
  },

  /**
   * History
   * @route GET /transaction/history
   */
  history: function (req, res) {
    let {
      token = null,
      page = null,
      per_page: perPage = 25,
      from_date: startDate = null,
      to_date: endDate = null,
      table_number: tableNumber = null,
      shoe_number: shoeNumber = null,
      game_code: gameCode = ['baccarat']
    } = req.query;
    let tasks;
    let playerName = '';

    tasks = {
      validation: (next) => {
        // console.log(`| #1 HISTORY |`);

        // Evaluate value
        page = parseInt(page);
        perPage = parseInt(perPage);

        startDate = moment(startDate).format('YYYY-MM-DD HH:mm:ss');
        endDate = moment(endDate).format('YYYY-MM-DD HH:mm:ss');

        // Validate parameters
        if (!token)
          return next({ error: `Invalid parameter [token] ${token}`});
        else if (!page)
          return next({ error: `Invalid parameter [page] ${page}`});
        else if (!startDate || _.isEqual(startDate, 'Invalid date'))
          return next({ error: `Invalid parameter [from_date] ${startDate}`});
        else if (!endDate || _.isEqual(endDate, 'Invalid date'))
          return next({ error: `Invalid parameter [to_date] ${endDate}`});
        else if (!gameCode)
          return next({ error: `Invalid parameter [game_code] ${gameCode}`});
        else
          return next();
      },

      verifyToken: ['validation', (arg, next) => {
        // console.log(`| #2 HISTORY |`);
        JwtService.valid(token)
          .catch((err) => {
            console.log(`| #2.1 HISTORY | Failed.`);
            return next(err)
          })
          .then((userInfo) => {
            console.log(`| #2.1 HISTORY | Success.`);
            playerName = _.get(userInfo, 'username', '[INVALID NAME]');
            return next(null, userInfo);
          });
      }],

      iChips: ['verifyToken', (arg, next) => {
        // console.log(`| #3 HISTORY |`);
        const { username } = arg.verifyToken;

        ICHIPS.transactions({
          username,
          start: (perPage * (page - 1)) + 1,
          length: perPage,
          startDate,
          endDate,
          tableNumber,
          shoeNumber,
          gameCode
        }, (error, data) => {
          if (error)
            return next(error);

          return next(null, {
            list: data.data,
            current_page: page,
            total_page: Math.ceil(data.count_records / perPage),
            total_records: data.count_records,
            total_results: data.count_results
          })
        });
      }]
    };

    // Execute tasks
    async.auto(tasks, (err, taskResults) => {
      if (err) {
        return res.badRequest({ err: err.error, status: 400 });
      }

      return res.json({
        status: 200,
        message: 'Transaction Pulled',
        data: taskResults.iChips
      })
    });
  },

  /**
   * Report for Rolling and Win/Loss
   * @param req
   * @param res
   * @route GET /transaction/reports
   */
  searchReports: function (req, res) {
    let params = req.body;
    let startDate, endDate, tasks;

    // Make sure this is a socket request (not traditional HTTP)
    // if (!req.isSocket)
    //   return res.badRequest({ err: 'Forbidden Request' });

    // Validators
    if (_.isUndefined(params.token))
      return res.badRequest({ err: 'Invalid Parameter: [token]'});
    if (_.isUndefined(params.fromDate))
      return res.badRequest({ err: 'Invalid Parameter: [fromDate]' });
    if (_.isUndefined(params.toDate))
      return res.badRequest({ err: 'Invalid Parameter: [toDate]' });

    // Pre-setting variables
    startDate = moment(params.fromDate).format('YYYY-MM-DD HH:mm:ss');
    endDate = moment(params.toDate).format('YYYY-MM-DD HH:mm:ss');

    tasks = {
      // Verify Token
      verifyToken: async function (cb) {
        await JwtService.valid(params.token)
          .then((token) => {
            return cb(null, token);
          })
          .catch((err) => {
            return cb(err)
          });
      },
      // Get rolling and win/loss summarized data
      rwl: ["verifyToken", function (arg, cb) {
        let query = "CALL TRANSACTION_RWL($1, $2, $3);";
        ResultList.getDatastore().sendNativeQuery(query, [
          arg.verifyToken.id,
          startDate,
          endDate
        ], function (err, data) {
          // Add default values in-case of crash
          return cb(err, data.rows[0].length ? data.rows[0][0] : { rolling: 0, win_loss: 0 });
        })
      }],
    };
    // Execute tasks
    async.auto(tasks, (err, results) => {
      if (err) return res.badRequest({ err: err });
      return res.ok({ status: 200, message: 'Successfully sent reports', data: results.rwl })
    })
  },

  /**
   * Betting History Records (Depreciated)
   * @param req
   * @param res
   * @route GET /transaction/records
   */
  searchRecords: function (req, res) {
    let params = _.isEmpty(req.body) ? req.query : req.body;
    let startDate, endDate, shoeNumber, perPage, page, tasks, tableID;

    // Make sure this is a socket request (not traditional HTTP)
    // if (!req.isSocket) return res.badRequest({ err: 'Forbidden Request' });

    // Validators
    if (_.isUndefined(params.token))
      return res.badRequest({ err: "Invalid Parameters [token]"});
    if (_.isUndefined(params.fromDate))
      return res.badRequest({ err: "Invalid Parameters [fromDate]" });
    if (_.isUndefined(params.toDate))
      return res.badRequest({ err: "Invalid Parameters [toDate]" });

    // Pre-setting variables
    // Set UTC Format of date when the in production or testing servers
    startDate = moment(params.fromDate).format('YYYY-MM-DD HH:mm:ss');
    endDate = moment(params.toDate).format('YYYY-MM-DD HH:mm:ss');

    tableID = _.isUndefined(params.table_id) || !params.table_id ? null : params.table_id;
    shoeNumber = _.isUndefined(params.shoehand_id) ? null : params.shoehand_id;
    perPage = _.isUndefined(params.perPage) ? 10 : params.perPage;
    page = _.isUndefined(params.page) ? 1 : params.page;

    // List of tasks
    tasks = {
      // Verify token
      verifyToken: async function (cb) {
        await JwtService.valid(params.token)
          .then((token) => {
            return cb(null, token);
          })
          .catch((err) => {
            return cb(err)
          });
      },
      // History
      history: ["verifyToken",  function (arg, cb) {
        let query = "CALL TRANSACTION_HISTORY($1, $2, $3, $4, $5, $6, $7);";
        ResultList.getDatastore().sendNativeQuery(query, [
          arg.verifyToken.id,
          startDate,
          endDate,
          shoeNumber,
          tableID,
          perPage,
          ((page - 1) * perPage)
        ], function (err, data) {
          // Parse JSON values of gameValue
          if (data) {
            data.rows[1] = data.rows[1].map(a => {a.gameValues = JSON.parse(a.gameValues); return a})
            return cb(err, {
              totalRows: data.rows[0][0]['totalRows'],
              list: data.rows[1]
            });
          } else {
            return cb(err, {
              totalRows: 0,
              list: []
            });
          }
        })
      }]
    };

    // Execute tasks
    async.auto(tasks, (err, results) => {

      if (err) { return res.badRequest({ err: err}); }
      return res.ok({
        err: err,
        status: 200,
        message: 'Successfully sent betting history',
        data: {
          betting_history: results.history.list,
          currentPage: page,
          totalPage: Math.ceil(results.history.totalRows / perPage),
          totalCurrentRows: results.history.totalRows.length,
          totalRows: results.history.totalRows
        }
      })
    });
  },

  /**
   * searchNewRecords
   * @param req
   * @param res
   * @returns {*}
   * @constructor
   * TO.DO - Alfie
   */
  searchNewRecords: function (req, res) {
    let historyList = [], totalRecords = 0, totalResult = 0, maxPage = 1, playerName = '', tasks;
    let {
      token = '',
      fromDate: startDate,
      toDate: endDate,
      table_id : tableNumber,
      shoehand_id: shoeNumber,
      game_code: gameCode,
      bet_code: betCode,
      perPage = 25,
      page = 1,
    } = _.isEmpty(req.body) ? req.query : req.body;

    console.log(JSON.stringify(_.isEmpty(req.body) ? req.query : req.body));

    // Validators
    if (_.isUndefined(token))
      return res.badRequest({ err: "Invalid Parameters [token]"});
    if (_.isUndefined(startDate))
      return res.badRequest({ err: "Invalid Parameters [fromDate]" });
    if (_.isUndefined(endDate))
      return res.badRequest({ err: "Invalid Parameters [toDate]" });

    startDate = moment(startDate).format('YYYY-MM-DD HH:mm:ss');
    endDate = moment(endDate).format('YYYY-MM-DD HH:mm:ss');
    tableNumber = _.isNumber(tableNumber) ? tableNumber : null;

    // List of tasks
    tasks = {
      // Verify token
      verifyToken: async function (next) {
        JwtService.valid(token)
          .then((tokenData) => {
            playerName = _.get(tokenData, 'username', '[INVALID NAME]');
            console.log(`| #1 HISTORY - ${playerName} | Token has been verified.`);
            return next(null, tokenData);
          })
          .catch((err) => {
            // console.log(`| #1 HISTORY | Failed to get details. [${token}]`);
            return next(err)
          });
      },

      // Get list of game codes
      gameCodeList: ['verifyToken', (arg, next) => {
        console.log(`| #2 HISTORY - ${playerName} | Pulling game codes.`);
        const query = 'SELECT b.gamecode AS gameCode, a.tablenumber AS tableNumber FROM `c_tablelist` a INNER JOIN c_gamecodes b on b.id = a.game_code_id WHERE a.studio = "prestige" AND a.id = IFNULL($1, a.id) GROUP BY `gamecode`';

        // If gameCode is present by pass query from database
        if (gameCode) {
          // Convert array if gameCode parameter send string only
          return next(null, {gameCodeList: _.isArray(gameCode) ? _.map(gameCode, o => { return { gameCode: o }}) : [{ gameCode }]});
        }
        // Execute query to get list of table code active
        sails.sendNativeQuery(query, [tableNumber], (err, data) => {
          return next(err, {gameCodeList: _.get(data, 'rows', [])});
        });
      }],

      // Search for I-Chips query
      iChipsHistory: ['gameCodeList', 'verifyToken', (arg, next) => {
        console.log(`| #3 HISTORY - ${playerName} | Getting history from I-Chips.`);
        const { gameCodeList = [] } = arg.gameCodeList;
        const { username = null } = arg.verifyToken;

        // Loop through game codes pulled
        async.eachSeries(gameCodeList, async (code, next) => {
          // Pull data from I-Chips
          const iChipsData = await ichipsApi('getHistory', {
            username: username,
            game_code: code.gameCode,
            // start: (perPage * (page - 1)) + 1,
            start: 1,
            length: 100,
            start_date: startDate,
            end_date: endDate,
            bet_code: betCode,
            table_number: tableNumber ? code.tableNumber : tableNumber,
            shoehandnumber: shoeNumber,
          })
            .intercept((err) => {
              return next(err)
            });

          // Handling pulled list
          const list = _.get(iChipsData, 'data', []);
          const totalGameRecord = _.get(iChipsData, 'count_records', 0);
          const totalGameResult = _.get(iChipsData, 'count_results', 0);

          // console.log(`| #3.1p HISTORY - ${playerName} | I-Chips ${_.toUpper(code.gameCode)} ${_.size(list)} bet(s) found.`);

          // If result is not empty append to history list
          if (!_.isEmpty(list)) {
            // Append all history
            historyList = _.concat(historyList, list);
            // Sum all records pulled in I-Chips
            totalRecords += totalGameRecord;
            totalResult += totalGameResult;

            const pageCtr = Math.ceil(totalGameRecord / totalGameResult);
            maxPage = pageCtr > maxPage ? pageCtr : maxPage;
            console.log(code.gameCode, totalRecords, totalResult, pageCtr, maxPage);
          }

          // Return success callback
          return next();
        }, (err) => {
          if (err)
            return next(err);

          // Sort data by created date
          historyList = _.sortBy(historyList, function(o) {
            return new moment(o.created_at).format('YYYY-MM-DD HH:mm:ss');
          }).reverse();

          return next();
        });
      }]
    };

    // Execute tasks
    async.auto(tasks, (err) => {
      if (err) {
        return res.badRequest({ err: err });
      }

      console.log(JSON.stringify({
        currentPage: page,
        totalPage: maxPage,
        totalCurrentRows: totalResult,
        totalRows: totalRecords
      }))

      return res.json({
        err: err,
        status: 200,
        message: 'Successfully pulled betting history',
        data: {
          betting_history: historyList,
          currentPage: page,
          totalPage: maxPage,
          totalCurrentRows: totalResult,
          totalRows: totalRecords
        }
      })
    });
  },

  /**
   * Betting History Records
   * @param req
   * @param res
   * @route GET /transaction/multiple_records
   */
  searchRecordsByMultiple: function (req, res) {
    let params = req.query;
    let startDate, endDate, shoeNumber, perPage, page, tasks, tableID, tables;

    // Validators
    if (_.isUndefined(params.token))
      return res.badRequest({ err: "Invalid Parameters [token]"});
    if (_.isUndefined(params.fromDate))
      return res.badRequest({ err: "Invalid Parameters [fromDate]" });
    if (_.isUndefined(params.toDate))
      return res.badRequest({ err: "Invalid Parameters [toDate]" });

    // Pre-setting variables
    // Set UTC Format of date when the in production or testing servers
    startDate = moment(params.fromDate).format('YYYY-MM-DD HH:mm:ss');
    endDate = moment(params.toDate).format('YYYY-MM-DD HH:mm:ss');

    tableID = _.isUndefined(params.table_id) || !params.table_id ? null : params.table_id;
    if (!_.isArray(JSON.parse(tableID)) && tableID)
      return res.badRequest({ err: "Table should be an array" })
    shoeNumber = _.isUndefined(params.shoehand_id) ? null : params.shoehand_id;
    perPage = _.isUndefined(params.perPage) ? 10 : params.perPage;
    page = _.isUndefined(params.page) ? 1 : params.page;
    tables = JSONParseSafe(tableID) || [];

    tasks = {

      verifyToken: async function (cb) {
        await JwtService.valid(params.token)
          .then((token) => {
            return cb(null, token);
          })
          .catch((err) => {
            return cb(err)
          });
      },

      // History
      history: ["verifyToken",  async function (arg, cb) {
        const CONDITION = " AND t0.table_id " + (_.isEmpty(tables) ? "= t0.table_id" : " IN (" + _.join(tables, ',') + ")");
        const limit_query = " ORDER BY t0.created_at LIMIT " + perPage + " OFFSET " + ((page - 1) * perPage);
        let QUERY01 = "SELECT t0.id, t0.bet_code, t0.balance, t0.win_loss, t0.table_id, t0.bet_amount, u.username, u.currency, t0.effective_bet_amount, t0.created_at as bet_date, s.shoehandnumber, t.gamename, t.tablenumber, bp.bet_place, rl.prefix as result, CASE WHEN (gc.gamecode = '3cards') THEN 'threecards' ELSE gc.gamecode END AS gamecode, gv.`values` as gameValues, t0.super_six AS isSuperSix, t0.is_emcee AS isEmcee FROM t_betdetails t0 LEFT JOIN c_tablelist t ON t.id=t0.table_id LEFT JOIN c_resultlist rl ON rl.id=t0.resultlist_id LEFT JOIN c_shoehand s ON s.id=t0.shoehand_id LEFT JOIN c_betplace bp ON bp.id=t0.betplace_id LEFT JOIN c_gamecodes gc ON gc.id=bp.gamecode_id LEFT JOIN t_game_values gv ON gv.result_id=t0.result_id LEFT JOIN t_user u ON u.id=t0.user_id WHERE t0.user_id = IFNULL($1, t0.user_id) AND t0.created_at BETWEEN DATE_FORMAT($2, '%Y-%m-%d 00:00:00') AND DATE_FORMAT($3, '%Y-%m-%d 23:59:59') AND s.shoehandnumber LIKE CONCAT(IFNULL($4, s.shoehandnumber),'%')" + CONDITION + limit_query;
        let QUERY02 = "SELECT COUNT(t0.id) as totalRows FROM  t_betdetails t0  LEFT JOIN c_shoehand t1 ON t0.shoehand_id = t1.id WHERE t0.user_id = IFNULL($1, t0.user_id) AND t0.created_at BETWEEN DATE_FORMAT($2, '%Y-%m-%d 00:00:00') AND DATE_FORMAT($3, '%Y-%m-%d 23:59:59') AND t1.shoehandnumber LIKE CONCAT(IFNULL($4, t1.shoehandnumber),'%')" + CONDITION;

        async.auto({
          dataList: async (cb) => {
            await sails.sendNativeQuery(QUERY01, [
              arg.verifyToken.id,
              startDate,
              endDate,
              shoeNumber
            ], cb);
          },
          pagination: ["dataList", async (_arg, cb) => {
            await sails.sendNativeQuery(QUERY02, [
              arg.verifyToken.id,
              startDate,
              endDate,
              shoeNumber
            ], cb)
          }]
        }, (err, taskResults) => {
          if (err) return cb(err, { totalRows: 0, list: [] });

          _.map(taskResults.dataList.rows, (o) => {
            o.gameValues = JSONParseSafe(o.gameValues) || {};
          });

          return cb(err, {
            totalRows: _.get(taskResults, "pagination.rows[0].totalRows", 0),
            list: _.get(taskResults, "dataList.rows", [])
          });
        });
      }]
    };

    // Execute tasks
    async.auto(tasks, (err, results) => {
      if (err) { return res.badRequest({ err: err}); }
      console.log('gegegeee --', Math.ceil(results.history.totalRows / perPage))
      return res.ok({
        err: err,
        status: 200,
        message: 'Successfully sent betting history',
        data: {
          betting_history: results.history.list,
          currentPage: page,
          totalPage: Math.ceil(results.history.totalRows / perPage),
          totalCurrentRows: results.history.totalRows.length,
          totalRows: results.history.totalRows
        }
      })
    });
  },

  getAllTransactions: function (req, res) {
    let params = req.isSocket ? req.body : req.query
    let today = new Date()
    let fromDate = params.fromDate
    let toDate = params.toDate
    let shoehand_id = params.shoehand_id ? params.shoehand_id : null
    let table_id = params.table_id ? params.table_id : null
    let perPage = params.perPage ? params.perPage : 10
    let page = params.page ? params.page: 1
    const token = params.token ? params.token: 'xxxx';
    const reqip = req.headers["x-forwarded-for"] || req.ip;

    if (process.env.NODE_ENV === 'development') {
      fromDate = fromDate ? moment(fromDate).format('YYYY-MM-DD HH:mm:ss') : undefined
      toDate = toDate ? moment(toDate).format('YYYY-MM-DD HH:mm:ss') : undefined
    } else {
      fromDate = fromDate ? moment(fromDate).utc().format('YYYY-MM-DD HH:mm:ss') : undefined
      toDate = toDate ? moment(toDate).utc().format('YYYY-MM-DD HH:mm:ss') : undefined
    }

    // let shoe_date_query = shoehand_id ? " AND bt.shoehand_id = " + shoehand_id : ""
    let shoe_date_query = shoehand_id ? " s.shoehandnumber = '" + shoehand_id + "'" : ""
    let table_id_query = table_id ? " AND bt.table_id = " + table_id : ""
    let date_query = fromDate ? " bt.created_at BETWEEN '" + fromDate + "' AND '" + toDate + "'": ""
    let where = " WHERE" + shoe_date_query + table_id_query + date_query
    let limit_query = " LIMIT " + perPage
    let offset_query = " OFFSET " + ((page - 1) * perPage)
    let order_query = " ORDER BY bt.id DESC"

    const tasks = {
      getBettingDetailsCount: function (next) {
        let query = "SELECT COUNT(*) as totalRows FROM t_betdetails bt WHERE" + date_query + table_id_query
        Bettings.getDatastore().sendNativeQuery(query, [], function (err, count) {
          return next(err, count.rows[0].totalRows)
        })
      },
      getBettingDetails: function (next) {
        let query = "SELECT bt.id, bt.bet_code, bt.balance, bt.win_loss, bt.table_id, bt.bet_amount, bt.effective_bet_amount, DATE_FORMAT(bt.created_at, '%Y-%m-%dT%T+00:00') as bet_date, s.shoehandnumber, t.gamename, t.tablenumber, bp.bet_place, rl.prefix as result , gc.gamecode FROM t_betdetails bt LEFT JOIN c_tablelist t ON t.id=bt.table_id LEFT JOIN c_resultlist rl ON rl.id=bt.resultlist_id LEFT JOIN c_shoehand s ON s.id=bt.shoehand_id LEFT JOIN c_betplace bp ON bp.id=bt.betplace_id LEFT JOIN c_gamecodes gc ON gc.id=bp.gamecode_id" + where + order_query + limit_query + offset_query
        Bettings.getDatastore().sendNativeQuery(query, function (err, resultlists) {
          if (err) return next (err)
          return next(err, resultlists.rows)
        })
      }
    };

    async.auto(tasks, (err, results) => {
      if (err) { return res.serverError(JSON.stringify(err)); }
      let totalPage = Math.ceil(results.getBettingDetailsCount / perPage)
      return res.ok({status: 200, message: 'Successfully sent betting history', data: {betting_history: results.getBettingDetails, currentPage: page, totalPage, totalCurrentRows: results.getBettingDetails.length, totalRows: results.getBettingDetailsCount} })
    })
  },

  /**
   * Transfer Validation
   * @route GET /transaction/transfer/validation
   * @param req transactions
   * @param res
   */
  transferValidation: (req, res) => {
    const {
      id = null,
      type = null,
      amount = null,
      user_name: userName = null
    } = req.query;
    let tasks;

    tasks = {
      validation: (next) => {
        if (!id)
          return next({error: `Invalid Parameter: [id]`});
        else if (!type)
          return next({error: `Invalid Parameter: [type]`});
        else if (!amount)
          return next({error: `Invalid Parameter: [amount]`});
        else if (!userName)
          return next({error: `Invalid Parameter: [userName]`});
        else
          return next();
      },
      iChips: ['validation', (arg, next) => {
        // Call for iChips validation of transfer
        ICHIPS.transferValidation({id, type, amount, userName}, next);
      }]
    };

    async.auto(tasks, (err, taskResult) => {
      if (err) {
        res.badRequest(err);
      }

      return res.json({ status : taskResult.iChips });
    });
  }
};

function JSONParseSafe(value) {
  try { return JSON.parse(value) } catch(e) { return value }
}
